---
title: Java内存模型与线程
date: 2019-10-23 16:03:02
tags:
category: JVM
---

## Java内存模型

### 主内存与工作内存

所有变量（包括了实例字段、静态字段和构成数组对象的元素，但不包含局部变量与方法参数）都存储在主内存，每条线程还有自己的工作内存。线程中的工作内存保存了被该线程使用到的变量的主内存副本拷贝，线程见变量值的传递均需要通过主内存来完成。

### 内存间交互操作

8种操作：

（1）lock(锁定)：作用于主内存的变量，把一个变量标记为一条线程独占状态
（2）unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
（3）read(读取)：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
（4）load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中
（5）use(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎
（6）assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量
（7）store(存储)：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作
（8）write(写入)：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中

这些基本操作必须满足如下规则：

1）不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步会主内存中
2）一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或者assign）的变量。即就是对一个变量实施use和store操作之前，必须先自行assign和load操作。
3）一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现。
4）如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量之前需要重新执行load或assign操作初始化变量的值。
5）如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。
6）对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）

### 对于volatile型变量的特殊规则

当一个变量被定义为volatile之后，它将具备两种特性：

- 可见性：当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。
  - volatile变量对所有线程是立即可见的，对volatile变量的所有写操作都能立刻反应到其他线程中，换句话说，volatile变量在各个线程中是一致的，所有基于volatile变量的运算在并发下是安全的。❌：Java里面的运算并非原子操作
  - 以下两种运算场景中可以使用volatile变量，否则需要通过加锁（使用synchronized或java.util.concurrent中的原子类）来保证原子性
    - 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值
    - 变量不需要与其他的状态变量共同参与不变约束

- 禁止指令重排序优化
  - 有volatile修饰的变量多执行了一个“lock addl $0x0, (%esp)”（把ESP寄存器的值加0）操作。
  - 作用相当于对Cache中的变量做了一次“store和write”操作，意味着所有之前的操作都已经完成。

### 对于long和double型变量的特殊规则

非原子协定：对于long和double这种64位的数据类型，允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行。

而实际开发中，虚拟机几乎都选择将64位数据的读写操作作为原子操作来对待。

### 先行发生原则

Java内存模型下一些“天然的”先行发生关系。

1. 程序次序规则 
   一个线程内，按照程序代码的顺序，书写在前面的操作先行发生于(逻辑上)书写在后面的操作。 

2. 管程锁定规则 
   一个unlock操作先行发生于后面对同一个锁的lock操作。后面指时间上的先后顺序。

3. volatile变量规则 
   对一个volatile变量的写操作先行发生于后面对这个变量的读操作。这里的后面指时间上的先后顺序。 

4. 传递性 
   如果操作A先行发生于操作B，操作B先行发生于操作C，那么，操作A也就先行发生于操作C。 

5. 线程启动规则 
   Thread对象的start方法先行发生于此线程的每个动作； 

6. 线程终止规则 
   线程中的所有操作都先行发生于对此线程的终止检测； 

7. 线程中断规则 
   对线程的interrupt（）方法的调用先行发生于被中断线程的代码检测到中断时间的发生； 

8. 对象终结规则 
   一个对象的初始化完成先行发生于它的finalize()方法的开始

9. 传递性

   如果操作A先行发生于操作B，B先行发生于C，则A先行发生于C

## Java线程

### 线程的实现

1. 内核线程实现

- 轻量级进程与内核线程之间是1:1的关系
- 优点：
  - 各种线程操作，如创建、析构及同步由系统调用完成，不需要用户线程考虑
- 缺点：
  - 各种线程操作，如创建、析构及同步都需要系统调用，代价较高
  - 每个轻量级进程都需要一个内核线程的支持，而内核资源有限，因此一个系统支持轻量级进程的数量有限

2. 用户线程实现

- 进程与用户线程之间位1:N的一对多的线程模型
- 优点：
  - 完全建立在用户空间的线程库上，建立、同步、销毁和调度不需要内核的帮助，因此更快速、低消耗、可以支持规模更大的线程数量
- 缺点：
  - 线程操作如创建、切换和调度等，都需要用户程序自己处理，解决起来异常困难

3. 用户线程加轻量级进程混合实现

4. Java线程的实现：基于操作系统原生线程模型来实现

### Java线程调度

线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度和抢占式线程调度。Java采用的是抢占式调度。

- 协同式调度

  - 线程的执行时间由线程本身来控制，线程把自己工作执行完了之后，要主动通知系统切换到另外一个线程上。
  - 好处：实现简单
  - 坏处：如果一个线程编写有问题，那么程序就会一致阻塞在那里

- 抢占式调度

  - 每个线程由系统来分配执行时间

  - ”建议“给某些线程多分配一点时间，另外一些少分配一点——可以通过设置线程优先级来完成

### 状态转换

Java定义了5种线程状态，任意一个时间点，线程有且仅有一种状态：新建、运行、无限期等待、限期等待、阻塞和结束。