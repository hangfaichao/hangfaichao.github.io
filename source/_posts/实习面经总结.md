---
title: 实习面经总结
date: 2020-02-06 15:18:36
tags:
category: JOB
---

# 操作系统

#### 1 进程与线程的区别

进程：

- 资源分配的最小单位
- 进程有独立的寻址空间，建立和切换进程代价昂贵。每建立一个进程，系统就会为这个进程分配地址空间，建立数据表来维护代码段、堆栈段和数据段。
- 进程之间的通信需要以通信的方式（IPC）进行
- 多进程程序更加健壮。进程地址空间独立，一个进程死掉不会影响其他进程。

线程：

- 资源调度的最小单元（程序运行的最小单元）
- 同一个进程中的线程可以共享数据，新建和切换线程开销小的多。
- 线程共享全局变量静态变量，通信更加简单，不过要处理好同步和互斥的问题。
- 多线程程序只要一个线程死掉了，整个进程就死掉了。

[参考](https://www.jianshu.com/p/2dc01727be45)

#### 2 什么是协程

协程，又称微线程。

子程序，或者说是函数，在所有语言中都是层级调用，总是一个入口，一个返回，调用顺序是明确的。

而协程的执行过程中，内部可中断，转而执行别的子程序，在适当的时候在返回接着执行。这个过程不是函数调用，有点类似CPU的中断。

协程比线程的优势是，执行效率高（子程序切换不是线程切换，而是程序自身控制）以及不需要多线程的锁机制（因为只有一个线程，没有同时写变量冲突）

[参考](https://www.liaoxuefeng.com/wiki/897692888725344/923057403198272)

#### 3 进程间通信方式（IPC）

- 管道（pipe）：
  - 管道分为匿名管道和命名管道，匿名管道可用于具有亲缘关系进程间的通信（半双工），命名管道允许无亲缘关系进程间的通信。常见的Linux命令中的"|"就是匿名管道，例如：echo "hangfaichao" | awk -F 'i' '{print $2}' #输出chao；另外，可以通过mkfifo \<pipename>命令创建一个命名管道，例如：mkfifo pipe，然后在两个终端中，一个终端输入echo "hangfaichao" > pipe，另一个输入cat < pipe，就能读到字符串，另一个终端没有输入时，第一个终端一直阻塞。
  - 最后一个访问管道的进程中之后，管道就会被完全删除，不能用来对多个接收者广播数据。
  - 管道中的数据被当作字节流，因此无法识别信息的边界。
- 信号（signal）：
  - 信号是Unix系统中最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事情，他也是用户进程之间通信和同步的一种原始机制。一个键盘中断或者一个错误条件都可能产生一个信号。
- 消息队列：
  - 消息队列就是一个消息的链表，它允许一个或多个进程向它写消息，一个或多个进程向它读消息。Linux维护了一个消息队列向量表：msgque，来表示系统中所有的消息队列，系统中同时最多可以有128个消息队列
  - 消息队列是不连续的、有格式的信息，处理有很大灵活性
  - 小消息的传送效率很高，但大消息传送性能较差，因为消息传送过程中要经过从用户空间到内核空间，再从内核空间到用户空间的拷贝
  - 消息队列不支持广播，而且内核不知道消息的接受者
- 共享内存：
  - 通常由一个进程创建，其余进程对这块内存区进行读写
  - 得到共享内存有两种方式，映射/dev/mem设备和内存映像文件。常用的是第二种，通过shmXXX函数族来实现
  - Linux对于共享内存无法做同步，需要程序自己来实现，很多时候程序是通过信号量来实现的
- 信号量：
  - 本质上是一个计数器，用来记录对某个资源（如共享内存）的存取状况

[参考1](https://www.ibm.com/developerworks/cn/linux/l-ipc/)，[参考2](https://baike.baidu.com/item/进程间通信/1235923?fr=aladdin)

#### 4 用户态和内核态

- inter x86架构的cpu一共有四个级别，0-3级，0级特权级最高。
- 当一个进程在执行自己的代码时，处于用户态，此时特权级最低，为3级，Ring3，如果要执行文件操作，网络数据发送等必须通过write、send等系统调用，进程会切换到Ring0，然后去内核地址空间去执行内核代码。这样，用户态的程序就不能随意操作内存地址空间，这种保护模式是通过内存页表操作等机制，保证进程间的地址不冲突。
- 用户态切换到内核态的三种方式：
  - 系统调用，例如：fork()
  - 异常，例如：缺页异常
  - 外围设备的中断，例如：硬盘读写操作完成
- 用户态到内核态的切换步骤：
  - 1）从当前进程的描述符中提取起内核栈的ss0和esp0信息
  - 2）使用ss0和esp0指向的内核栈将当前进程的cs,eip,eflags,ss,esp信息保存起来
  - 3）将先前由中断向量检索得到的中断处理程序的cs,eip信息装入相应的寄存器，开始执行中断处理程序

[参考](https://blog.csdn.net/qq_39823627/article/details/78736650)

#### 5 进程中的堆和栈，线程共享进程的哪些资源

堆：是进程中所有线程共享的。堆分为全局堆和局部堆，全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统堆进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。

栈：是线程独有的。保存线程运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈相互独立，操作系统在切换线程的时候会自动切换栈，就是切换SS/ESP寄存器，栈空间不需要在高级语言里面显示的分配和释放。

线程共享：地址空间、全局变量、打开的文件、子进程、闹铃、信号及信号服务程序、记账信息

线程独享：程序计数器、寄存器、栈、状态字

#### 6 操作系统内存管理方式，分页分段以及段页式的优缺点

虚拟地址、物理地址

base和limit寄存器：保证隔离性

内存管理单元（MMU）：进行虚拟内存到物理内存的映射和保护

动态加载、动态链接库：类似模块化思想，有些程序例如print()函数在内存中只存在一份，多个进程可以使用它



连续分配

进程放到哪一块空闲内存中：首次适应（用得最多）算法、下次适应、最佳适应、最差适应

现代操作系统不是连续分配，但上述算法可以适用在堆空间的分配上。

页式管理不是连续分配，物理空间、逻辑空间都不连续。

页式管理没有外部碎片，利用页表，页表可以使用分级链表、哈希表+链表、反表（物理内存的页表号->[进程ID+虚拟页号]）的数据结构来控制页表大小

页的大小总是2的整数次幂，选择页的大小为2的幂可以方便地将逻辑地址转换为页号和页偏移。如果逻辑地址空间为2^m，且页大小为2^n，那么逻辑地址的**高m-n位表示页号**，而**低n位表示页偏移**。页面越小，内部碎片越小，但是页表越大；页面越大，内部碎片越大，但是页表越小。

增加页表之后访问内存变成两次（一次查页表一次访问真正的物理内存）。利用快表（一个cache）提高速度。快表可以利用硬件进行并行查找页面号。



页式：

优点：没有外碎片，每个内碎片不超过页的大小。

缺点：程序全部装入内存，要求有相应的硬件支持，如地址变换机构缺页中断的产生和选择淘汰页面等都要求有相应的硬件支持。增加了机器成本和系统开销。

段式：

优点：可以充分实现共享和保护，便于动态申请内存，管理和使用统一化，便于动态链接

缺点：会产生碎片。

段页式：

优点：具有两者的优点。

缺点：由于管理软件的增加，复杂性和开销也增加。另外需要的硬件以及占用的内存也有所增加，使得执行速度下降。

[参考知乎](https://www.zhihu.com/question/50796850)，[B站操作系统，内存管理：37-48](https://www.bilibili.com/video/av11441024?p=39)，[CSDN](https://blog.csdn.net/smilesundream/article/details/70148878)

#### 7 页面置换算法有哪些， FIFO为什么不好？如何改进？LRU思想，手写LRU

1）最佳置换算法（OPT）：优先淘汰永远不被访问或者最长时间内不被访问的页面

2）先进先出算法（FIFO）：优先淘汰最早进入内存的页面

FIFO算法基于队列实现，只有FIFO算法会出现Belady现象，即内存中的物理块数量增加时，缺页率可能不减反增。

3）最近最久未使用算法（LRU）：优先淘汰最近最长时间未被访问过的页面

LRU是堆栈类算法，是“向前看”的，而OPT是“向后看”的。LRU算法性能较好，但是需要寄存器和栈的硬件支持。理论上可以证明，堆栈类算法不可能出现Belady现象。

实现：

- 使用数组+计数器：给CPU增加一个逻辑时钟或者计数器，每次存储访问，就把计数器加1。这样记下每个页面最后一次被访问的时间。缺点是1.插入数据、删除数据以及访问数据时，时间复杂度都是O(n)。2.时钟值会溢出。
- 使用链表：每访问一个页面，就将这个页面放到表尾，每次置换表头的页面。缺点是访问数据时复杂度为O(n)。
- 使用链表+HashMap

4）时钟置换算法（CLOCK），又称为最近未用算法（NRU）：优先淘汰最近未使用算法

实现：给每个页面关联一个使用位。首次装入内存时，使用位置为1；随后被访问到时，使用位也置为1。使用一个循环缓冲区保存这些页面和使用位，一个指针扫描这个缓冲区。当指针指向的页面使用位为0是置换出去，否则将指向的页面的使用位置为0。

[参考](https://blog.csdn.net/huyang0304/article/details/82694526)，[LRU实现](https://blog.csdn.net/elricboa/article/details/78847305)

#### 8 死锁条件和解决方式

8.1 什么是死锁

多个进程因为竞争资源而互相造成的一种僵局，若无外力作用，这些进程都将无法推进。

8.2 产生死锁的原因

1）系统资源的竞争

2）进程运行推进顺序不当

8.3 死锁的四个必要条件

1）互斥条件：一个资源只能被一个进程使用，即在一段时间内，某资源仅被一个进程所占有

2）占有且等待条件：进程已经保持了至少一个资源，又对提出了资源请求，而另一个资源已经被其他进程占有，此时，请求进程被阻塞，而对自己占有的资源保持不放

3）不可抢占条件：进程所占有的资源在使用完毕之前不可以被其他进程强行夺走

4）循环等待条件：若干进程形成首尾相连循环等待资源的关系

8.4 避免死锁的办法

1）预防 -- 确保系统不会进入死锁状态

a. 破坏“占有且等待”条件

方法一：所有进程在开始运行之前，必须一次性申请其运行过程中所需要的全部资源

​	优点：简单易行且安全

​	缺点：造成资源浪费，使进程经常发生饥饿现象

方法二：允许进程只获得运行初期所需要的资源就开始运行，运行过程中逐步释放掉使用完毕的资源再申请新的资源

b. 破坏“不可抢占”条件

在进程申请新资源被阻塞时，必须释放自己拥有的所有资源，以后需要使用的时候再申请。

缺点：实现复杂，影响进程工作效率，同时反复请求和释放资源会延长进程的进度，影响系统的吞吐量

c. 破坏循环等待条件

给每个资源编号，当一个进程占有资源i时，下一次只能申请编号大于i的资源。

缺点：低效，资源可能没有被其他进程所占有，但是却无法被进程申请得到。

2）避免 -- 在使用资源之前进行判断

如果一个进程的请求会导致死锁就不启动该进程，如果一个进程增加资源的请求会导致死锁就拒绝该请求。

具体实现通常采用***银行家算法***。

3）检测与解除

检测：检测算法<<<<待解决<<<<

解除：抢占资源、终止进程（可根据进程优先级、已运行时间、还需运行时间、已占用资源等）

[参考](https://blog.csdn.net/guaiguaihenguai/article/details/80303835)

