---
title: 线程安全与锁优化
date: 2019-11-04 20:15:51
tags:
category: JVM 
---

# 1 线程安全

定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象的线程安全的。

弱化版：将“调用这个对象的行为”改为“单次调用”。

## 1.1 Java语言中的线程安全

按照线程安全的“安全程度”由强至弱来排序，可以将Java语言中各种操作共享的数据分为以下5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。

- 不可变
  - 如果共享数据是一个基本数据类型，则在定义时使用final关键字修饰它就可以保证它是不可变的
  - 如果共享数据时一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行（最简单的方法是把对象中带有状态的变量都声明为final）。例如java.lang.String类的对象，我们调用它的substring()、replace()和concat()这些方法都不会影响它原来的值，只会返回一个新构造的字符串对象。
- 绝对线程安全
  - 一个类要达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”通常需要付出很大的，甚至有时候是不切实际的代价。在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。
- 相对线程安全
  - 通常意义上所说的线程安全，需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。
  - Java语言中的大部分线程安全类都属于这种类型，例如Vector、HashTable、Collections的synchronizedCollection()方法包装的集合等。
- 线程兼容
  - 对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。
  - 我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。
- 线程对立
  - 无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。
  - 一个例子是Thread类的suspend()和resume()方法，如果两个线程同时持有一个线程对象，一个尝试去中断线程、另一个尝试去恢复线程，如果并发进行的话，无论调用时是否进行了同步，目标线程都是存在死锁风险的。

## 1.2 线程安全的实现方法

### 1.2.1 同步互斥

同步：多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用

互斥：实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方法。

互斥是因，同步是果；互斥是方法，同步是目的。

- synchronized关键字
  - 最基本的互斥同步手段
  - synchronized关键字经过编译后，会在同步块的前后分别形成monitorenter和monitorexit两个字节码指令
  - 执行monitorenter指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。
  - synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的情况
  - synchronized是Java语言中一个重量级的操作，阻塞或唤醒一个线程，都需要操作系统来帮忙（从用户态转换到核心态）
- java.util.concurrent重入锁 ReentrantLock
  - 基本用法上与synchronized很相似，都具备一样的线程重入特性
  - 代码写法上有区别，表现为API层面的互斥锁（lock()和unlock()方法配合try/finally语句块来完成）
  - 三个高级功能：
    - 等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情
    - 可实现公平锁：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁
    - 锁可以绑定多个条件：一个ReetrantLock对象可以同时绑定多个Condition对象

JDK1.6之后两者性能差别基本持平了，所以还是提倡在synchronized能实现需求的情况下，优先考虑使用synchronized来进行同步。

### 1.2.2 非阻塞同步

互斥同步的锁也成为阻塞同步，属于一种悲观锁（总是认为只要不去做正确的事，就肯定会出现问题，无论数据是否出现竞争，都要进行加锁、用户态和心态转换等操作）。

随着硬件指令集的发展，出现了另一个选择：基于冲突检测的乐观并发策略。也称为非阻塞同步。

硬件保证一个语义上看起来需要多次操作的行为只通过一条处理器指令就能完成，这类指令常用的有：

- 测试并设置（Test-and-Set）
- 获取并增加（Fetch-and-Increment）
- 交换（Swap）
- 比较并交换（Compare-and-Swap，简称CAS）
- 加载链接/条件存储（Load-Linked/Store-Conditional，简称LL/SC）

### 1.2.3 无同步方案

如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。因此有一些代码天生就是线程安全的。

- 可重入代码
  - 在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），在控制权返回后，原来的程序不会出现任何错误。
  - 判断方法：一个方法，只要输入了相同的数据，就都能返回同样的结果，那它就满足可重入性的要求。
- 线程本地存储
  - 如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能，就可以把共享数据的可见范围限制在同一个线程内，这样，无须同步也能保证不出现数据争用问题。

# 2 锁优化

从JDK1.5到JDK1.6，HotSpot虚拟机开发团队花费了大量精力去实现各种锁优化技术，如适应性自旋锁、锁消除、锁粗化、轻量级锁和偏向锁等等。

## 2.1 自旋锁与自适应锁

如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否会很快就释放锁。为了让线程等待，我们就只需让线程执行一个忙循环（自旋），这项技术就是自旋锁。

## 2.2 锁消除

锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。

## 2.3 锁粗化

原则上，总是推荐将同步块的作用范围限制得尽量小，但如果一系列的连续操作都对同一个对象反复加锁和解锁，虚拟机就会把加锁同步的范围扩展（粗化）到整个操作序列的外部。

## 2.4 轻量级锁

在没有多线程竞争的前提下，通过CAS操作减少传统的重量级锁使用操作系统互斥量产生的性能消耗。HotSpot虚拟机的对象头分为两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄等，它是实现轻量级锁和偏向锁的关键

轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据，但如果存在锁竞争，除了互斥量的开销外，还额外增加了CAS操作，因此在有竞争的的情况下，轻量级锁会比传统的重量级锁更慢。

## 2.5 偏向锁

在无竞争的情况下把整个同步都消除掉，包括CAS操作也不做了。