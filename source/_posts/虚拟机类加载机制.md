---
title: 虚拟机类加载机制
date: 2019-10-04 16:45:44
tags:
category: JVM 
---

与那些在编译时需要进行连接工作的语言不同，在Java语言中，类的加载、连接和初始化过程都是在程序运行期间完成的。Java里天生可以动态扩展的语言特性就是依赖运行期间动态加载和动态连接这个特点实现的。

## 类加载的时机

类从被加载到虚拟机内存中开始，到卸载出内存为止，整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载。其中验证、准备、解析3个部分统称为连接。

加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，必须按这个顺序按部就班开始。

什么情况下需要开始加载？Java虚拟机规范并没有强制要求，但对于初始化阶段，则规定了有且只有5种情况必须立即对类进行初始化（而加载要在这之前开始）：

1. 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时
2. 使用java.lang.reflect包的方法对类进行反射调用时
3. 初始化一个类时，发现其父类还未进行初始化时，首先对父类进行初始化
4. 虚拟机启动时，会初始化主类
5. 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化

## 类加载的过程

类加载的全过程包括加载、验证、准备、解析和初始化这5个阶段

### 加载

在加载阶段，虚拟机需要完成以下三件事：

1. 通过一个类的全限定名来获取定义此类的二进制流（没有指明从哪里获取、怎样获取，可从Class文件、JAR包等等）
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

### 验证

连接阶段的第一步，目的是确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

验证阶段的工作量在整个虚拟机的类加载子系统中占了相当大的一部分。

大致会完成下面四个阶段的工作：

- 文件格式验证：基于二进制字节流
- 元数据验证：对类的元数据进行语义校验
- 字节码验证：通过对数据流和控制流分析，确定程序语义是合法的，符合逻辑的
- 符号引用验证：确保解析动作能正常执行

### 准备

准备阶段是正式为类变量（被static修饰的变量）分配内存并设置类变量初始值（数据类型的零值）的阶段，这些变量所使用的内存都将在方法区中进行分配。

### 解析

虚拟机将符号引用转化为直接引用的过程。

- 符号引用：可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。与虚拟机内存布局无关
- 直接引用：可以直接指向目标的指针、相对偏移量或一个能间接定位到目标的句柄。与虚拟机内存布局相关。

分为类或接口的解析、字段解析、类方法解析、接口方法解析。

### 初始化

从另一个角度，初始化阶段是执行类构造器\<clinit\>()方法的过程。

- \<clinit\>()方法是由编译器自动收集类中的所有类变量的赋值操作和静态语句块（static{}）中的语句合并产生的。静态语句块中只能访问到定义在静态语句块之前的变量，定义在之后的变量，只能赋值，不能访问。
- \<clinit\>()方法与类的构造函数不同，不需要显示调用父类构造器，虚拟机会保证父类的\<clinit\>()方法执行完毕。
- 父类的静态语句块要优于子类的变量赋值操作。
- \<clinit\>()方法对于类或接口来说并不是必需的。
- 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成\<clinit\>()方法。
- 虚拟机会保证一个类的\<clinit\>()方法在多线程环境中被正确地加载、同步。多个线程同时初始化一个类时，只有一个线程去初始化，其他的线程阻塞等待。

## 类加载器

虚拟机设计团队把类加载阶段中的加载动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块被称为“类加载器”。

### 类与类加载器

对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。

### 双亲委派模型

从Java虚拟机的角度只存在两种不同的类加载器：

- 启动类加载器：c++语言实现，是虚拟机自身的一部分
- 其他的类加载器：Java语言实现，独立于虚拟机外部，都继承自抽象类java.lang.ClassLoader

从Java开发人员的角度看：

- 启动类加载器：负责将存放在\<JAVA_HOME\>\lib目录中的，或者是被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中
- 扩展类加载器：由sun.misc.Launcher$ExtClassLoader实现，负责加载\<JAVA_HOME\>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库
- 应用程序类加载器：由sun.misc.Launcher$AppClassLoader实现，负责加载用户类路径（ClassPath）上所指定的类库