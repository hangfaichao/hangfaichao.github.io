---
title: JAVA垃圾收集与内存分配
date: 2019-09-21 09:57:51
tags: JAVA, GC
category: JVM
---

## 对象已死吗

判断对象是“活着”还是“死去”

### 引用计数算法

给对象添加一个引用计数器。

- 每当一个地方引用它时，计数加1；
- 引用失效时，计数减1；
- 任何时刻计数器为0的对象就不可能再被使用。

大部分情况时不错的算法，但：很难解决对象之间的相互循环引用的问题

### 可达性分析算法

基本思想：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径，当一个对象从GC Roots不可达时，将被判定为可回收对象。

可作为GC Roots的对象：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI（Native方法）引用的对象

### 再谈引用

- 强引用：Object obj = new Object()，垃圾收集器永远不会回收被引用的对象
- 软引用：描述一些还有用但并非必需的对象。在系统抛出内存异常之前会把这些对象列进回收范围进行二次回收。如果这次回收还没有足够的内存才会抛出内存异常。
- 弱引用：也是描述有用但并非必需的对象，但强度比软引用要弱一些。被弱引用关联的对象只能生存到下一次垃圾回收之前。当垃圾收集工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
- 虚引用：最弱的引用关系。对象是否有虚引用，完全不会对对其生存造成任何影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的是能在这个对象被收集器回收时收到一个系统通知。

### 生存还是死亡

两次标记过程：

1. 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将**第一次**被标记。
2. 第一次标记的同时进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法或finalize()方法已被虚拟机调用过（finalize()方法只会被执行一次），虚拟机将这两种情况都视为“没有必要执行”。如果对象有必要执行finalize()方法，那么这个对象将会被放置在一个叫做F-queue的队列中，并在稍候由一个虚拟机自动创建的、低优先级的Finalizer线程去执行它。finalize()方法是对象逃脱死亡命运的最后一次机会。
3. 稍后GC将对F-Queue中的对象进行**第二次**标记，这时候对象还没有逃脱，那基本上它就真的被回收了。

### 回收方法区

永久代的垃圾手机主要回收两部分内容：废弃常量和无用的类。

废弃常量：没有任何地方引用了常量池中的这个常量，例如字符串“abc”

无用的类：满足以下三个条件的可以回收，但不一定回收，可以通过-Xnoclassgc参数控制：1）该类的所有实例都已经被回收，也就是Java堆中不存在该类的任何实例，2）加载该类的ClassLoader已经被回收，3）该类对应的java.lang.Class对象没有在任何地方被引用，无法再通过反射访问该类的方法。

## 垃圾收集算法

- 标记-清除算法
  - 缺点：标记和清除效率都不高，空间碎片问题
- 复制算法
  - 将内存按照容量分为大小相等的两块。当这一块的内存用完了，就将还存活着的对象复制到另一块上去，再一次性把已使用过的内存空间清理掉。
  - 优点：实现简单，运行高效
  - 缺点：内存缩小为了原来的一半（可通过Eden:Survivor:Survivor=8:1:1改善）
- 标记-整理算法
  - 与标记-清除算法一样，但后续步骤不直接堆可回收对象进行清理，而是让它们都像一端移动
- 分代收集算法 
  - 根据对象的存活周期的不同将内存分为几块，一般是新生代和老年代。新生代只用复制算法，老年代使用标记-清除或标记-整理算法。